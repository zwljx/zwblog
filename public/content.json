{"meta":{"title":"zwblog","subtitle":"","description":"","author":"zw","url":"https://zwljx.github.io","root":"/"},"pages":[{"title":"","date":"2021-10-21T07:51:01.737Z","updated":"2021-10-21T07:51:01.737Z","comments":true,"path":"about/index.html","permalink":"https://zwljx.github.io/about/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-10-21T07:37:48.972Z","updated":"2021-10-21T07:37:48.972Z","comments":true,"path":"tags/index.html","permalink":"https://zwljx.github.io/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2021-10-21T07:50:40.265Z","updated":"2021-10-21T07:50:40.265Z","comments":true,"path":"categories/index.html","permalink":"https://zwljx.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-10-21T07:29:32.000Z","updated":"2021-10-21T07:29:32.264Z","comments":true,"path":"friends/index.html","permalink":"https://zwljx.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"TestNG-生成自定义格式的报告","slug":"TestNG-Report","date":"2021-10-25T03:29:53.000Z","updated":"2021-10-25T03:31:30.108Z","comments":true,"path":"2021/10/25/TestNG-Report/","link":"","permalink":"https://zwljx.github.io/2021/10/25/TestNG-Report/","excerpt":"继承IReporter实现自定义报告","text":"继承IReporter实现自定义报告 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179public class ExtentTestNGIReporterListener implements IReporter &#123; //生成的路径以及文件名 private static final String OUTPUT_FOLDER = &quot;test-output/&quot;; private static final String FILE_NAME = &quot;index.html&quot;; private ExtentReports extent; @Override public void generateReport(List&lt;XmlSuite&gt; xmlSuites, List&lt;ISuite&gt; suites, String outputDirectory) &#123; init(); boolean createSuiteNode = false; if(suites.size()&gt;1)&#123; createSuiteNode=true; &#125; for (ISuite suite : suites) &#123; Map&lt;String, ISuiteResult&gt; result = suite.getResults(); //如果suite里面没有任何用例，直接跳过，不在报告里生成 if(result.size()==0)&#123; continue; &#125; //统计suite下的成功、失败、跳过的总用例数 int suiteFailSize=0; int suitePassSize=0; int suiteSkipSize=0; ExtentTest suiteTest=null; //存在多个suite的情况下，在报告中将同一个一个suite的测试结果归为一类，创建一级节点。 if(createSuiteNode)&#123; suiteTest = extent.createTest(suite.getName()).assignCategory(suite.getName()); &#125; boolean createSuiteResultNode = false; if(result.size()&gt;1)&#123; createSuiteResultNode=true; &#125; for (ISuiteResult r : result.values()) &#123; ExtentTest resultNode; ITestContext context = r.getTestContext(); if(createSuiteResultNode)&#123; //没有创建suite的情况下，将在SuiteResult的创建为一级节点，否则创建为suite的一个子节点。 if( null == suiteTest)&#123; resultNode = extent.createTest(r.getTestContext().getName()); &#125;else&#123; resultNode = suiteTest.createNode(r.getTestContext().getName()); &#125; &#125;else&#123; resultNode = suiteTest; &#125; if(resultNode != null)&#123; resultNode.getModel().setName(suite.getName()+&quot; : &quot;+r.getTestContext().getName()); if(resultNode.getModel().hasCategory())&#123; resultNode.assignCategory(r.getTestContext().getName()); &#125;else&#123; resultNode.assignCategory(suite.getName(),r.getTestContext().getName()); &#125; resultNode.getModel().setStartTime(r.getTestContext().getStartDate()); resultNode.getModel().setEndTime(r.getTestContext().getEndDate()); //统计SuiteResult下的数据 int passSize = r.getTestContext().getPassedTests().size(); int failSize = r.getTestContext().getFailedTests().size(); int skipSize = r.getTestContext().getSkippedTests().size(); suitePassSize += passSize; suiteFailSize += failSize; suiteSkipSize += skipSize; if(failSize&gt;0)&#123; resultNode.getModel().setStatus(Status.FAIL); &#125; resultNode.getModel().setDescription(String.format(&quot;Pass: %s ; Fail: %s ; Skip: %s ;&quot;,passSize,failSize,skipSize)); &#125; buildTestNodes(resultNode,context.getFailedTests(), Status.FAIL); buildTestNodes(resultNode,context.getSkippedTests(), Status.SKIP); buildTestNodes(resultNode,context.getPassedTests(), Status.PASS); &#125; if(suiteTest!= null)&#123; suiteTest.getModel().setDescription(String.format(&quot;Pass: %s ; Fail: %s ; Skip: %s ;&quot;,suitePassSize,suiteFailSize,suiteSkipSize)); if(suiteFailSize&gt;0)&#123; suiteTest.getModel().setStatus(Status.FAIL); &#125; &#125; &#125;// for (String s : Reporter.getOutput()) &#123;// extent.setTestRunnerOutput(s);// &#125; extent.flush(); &#125; private void init() &#123; //文件夹不存在的话进行创建 File reportDir= new File(OUTPUT_FOLDER); if(!reportDir.exists()&amp;&amp; !reportDir .isDirectory())&#123; reportDir.mkdir(); &#125; ExtentHtmlReporter htmlReporter = new ExtentHtmlReporter(OUTPUT_FOLDER + FILE_NAME); // 设置静态文件的DNS //怎么样解决cdn.rawgit.com访问不了的情况 htmlReporter.config().setResourceCDN(ResourceCDN.EXTENTREPORTS); htmlReporter.config().setDocumentTitle(&quot;测试报告&quot;); htmlReporter.config().setReportName(&quot;测试报告&quot;); htmlReporter.config().setChartVisibilityOnOpen(true); htmlReporter.config().setTestViewChartLocation(ChartLocation.TOP); htmlReporter.config().setTheme(Theme.DARK); htmlReporter.config().setCSS(&quot;.node.level-1 ul&#123; display:none;&#125; .node.level-1.active ul&#123;display:block;&#125;&quot;); extent = new ExtentReports(); extent.attachReporter(htmlReporter); extent.setReportUsesManualConfiguration(true); &#125; private void buildTestNodes(ExtentTest extenttest, IResultMap tests, Status status) &#123; //存在父节点时，获取父节点的标签 String[] categories=new String[0]; if(extenttest != null )&#123; List&lt;TestAttribute&gt; categoryList = extenttest.getModel().getCategoryContext().getAll(); categories = new String[categoryList.size()]; for(int index=0;index&lt;categoryList.size();index++)&#123; categories[index] = categoryList.get(index).getName(); &#125; &#125; ExtentTest test; if (tests.size() &gt; 0) &#123; //调整用例排序，按时间排序 Set&lt;ITestResult&gt; treeSet = new TreeSet&lt;ITestResult&gt;(new Comparator&lt;ITestResult&gt;() &#123; @Override public int compare(ITestResult o1, ITestResult o2) &#123; return o1.getStartMillis()&lt;o2.getStartMillis()?-1:1; &#125; &#125;); treeSet.addAll(tests.getAllResults()); for (ITestResult result : treeSet) &#123; Object[] parameters = result.getParameters(); String name=&quot;&quot;; //如果有参数，则使用参数的toString组合代替报告中的name for(Object param:parameters)&#123; name+=param.toString(); &#125; if(name.length()&gt;0)&#123; if(name.length()&gt;50)&#123; name= name.substring(0,49)+&quot;...&quot;; &#125; &#125;else&#123; name = result.getMethod().getMethodName(); &#125; if(extenttest==null)&#123; test = extent.createTest(name); &#125;else&#123; //作为子节点进行创建时，设置同父节点的标签一致，便于报告检索。 test = extenttest.createNode(name).assignCategory(categories); &#125; //test.getModel().setDescription(description.toString()); //test = extent.createTest(result.getMethod().getMethodName()); for (String group : result.getMethod().getGroups()) test.assignCategory(group); List&lt;String&gt; outputList = Reporter.getOutput(result); for(String output:outputList)&#123; //将用例的log输出报告中 test.debug(output); &#125; if (result.getThrowable() != null) &#123; test.log(status, result.getThrowable()); &#125; else &#123; test.log(status, &quot;Test &quot; + status.toString().toLowerCase() + &quot;ed&quot;); &#125; test.getModel().setStartTime(getTime(result.getStartMillis())); test.getModel().setEndTime(getTime(result.getEndMillis())); &#125; &#125; &#125; private Date getTime(long millis) &#123; Calendar calendar = Calendar.getInstance(); calendar.setTimeInMillis(millis); return calendar.getTime(); &#125;&#125;","categories":[{"name":"TestNG","slug":"TestNG","permalink":"https://zwljx.github.io/categories/TestNG/"}],"tags":[{"name":"TestNG","slug":"TestNG","permalink":"https://zwljx.github.io/tags/TestNG/"}]},{"title":"TestNG-DataProvider-3","slug":"TestNG-Data-3","date":"2021-10-25T02:08:37.000Z","updated":"2021-10-25T03:21:05.812Z","comments":true,"path":"2021/10/25/TestNG-Data-3/","link":"","permalink":"https://zwljx.github.io/2021/10/25/TestNG-Data-3/","excerpt":"自定义mysql格式参数化文件处理工具类","text":"自定义mysql格式参数化文件处理工具类 工具类实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 public class MysqlData &#123; int rows; int columns; Connection connection; Statement statement; public MysqlData(String ip, String port, String databaseName, String userName, String password) &#123; try &#123; Class.forName(&quot;com.mysql.jdbc.Driver&quot;);//加载数据库驱动 String url = &quot;jdbc:mysql://&quot; + ip + &quot;:&quot; + port + &quot;/&quot; + databaseName;//数据库连接子协议 System.out.println(url); this.connection = DriverManager.getConnection(url, userName, password); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; /** * 通过传入的sql语句获取参数 * @return */ public Object[][] getMysqlDataBySQL(String sql)&#123; HashMap&lt;String, String&gt;[][] arrmap = null; //获取创建语句对象 try &#123; this.statement = connection.createStatement(); //执行sql语句，获取查询结果集 ResultSet result = statement.executeQuery(sql); //获取总行数 this.rows = 0; while(result.next()) &#123; rows++; &#125; result.beforeFirst(); //获取总列数 ResultSetMetaData rd = result.getMetaData(); this.columns = rd.getColumnCount(); // 为了返回值是Object[][],定义一个多行单列的二维数组 arrmap = new HashMap[rows][1]; if (rows &gt; 1) &#123; for (int i = 0; i &lt; rows; i++) &#123; arrmap[i][0] = new HashMap&lt;&gt;(); &#125; &#125; else &#123; System.out.println(&quot;sql查询结果集合中没有数据&quot;); &#125; //循环每行 int r = 0; while (result.next()) &#123; //循环每列，如果不要id，则i设为2 for (int i = 1; i &lt;= columns; i++) &#123; String key = result.getMetaData().getColumnName(i); String value = result.getString(i); arrmap[r][0].put(key, value); &#125; r++; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; return arrmap; &#125;&#125; 使用12345678910111213141516171819 public class MySQLDataProviderTest &#123; @DataProvider(name = &quot;num&quot;) public Object[][] Numbers() throws BiffException, IOException &#123; String ip = &quot;&quot;; String port = &quot;&quot;; String databaseName = &quot;&quot;; String user = &quot;&quot;; String password = &quot;&quot;; MysqlData mysqlData = new MysqlData(ip,port,databaseName,user,password); String sql = &quot;SELECT * FROM PHONE&quot;; return mysqlData.getMysqlDataBySQL(sql); &#125; @Test(priority = 1, dataProvider = &quot;num&quot;) public void test(HashMap&lt;String, String&gt; data)&#123; System.out.println(data.toString()); &#125;&#125;","categories":[{"name":"TestNG","slug":"TestNG","permalink":"https://zwljx.github.io/categories/TestNG/"}],"tags":[{"name":"TestNG","slug":"TestNG","permalink":"https://zwljx.github.io/tags/TestNG/"}]},{"title":"TestNG-DataProvider-1","slug":"TestNG-Data-2","date":"2021-10-25T01:56:06.000Z","updated":"2021-10-25T02:07:59.846Z","comments":true,"path":"2021/10/25/TestNG-Data-2/","link":"","permalink":"https://zwljx.github.io/2021/10/25/TestNG-Data-2/","excerpt":"自定义txt格式参数化文件处理工具类","text":"自定义txt格式参数化文件处理工具类 工具类实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class TxtData &#123; int rows; int columns; public String fileName; public String delimiter; public ArrayList&lt;String&gt; arrkey = new ArrayList&lt;String&gt;(); String sourceFile; public TxtData(String fileName, String delimiter)&#123; this.fileName = fileName; this.delimiter = delimiter; &#125; /** * 通过分隔符获取参数 * @return */ public Object[][] getTxtDataByDelimiter()&#123; List&lt;String&gt; dataList = null; try &#123; dataList = FileUtil.readFile(getPath()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; rows = dataList.size(); HashMap&lt;String, String&gt;[][] arrmap = new HashMap[rows - 1][1]; if (rows &gt; 1) &#123; for (int i = 0; i &lt; rows - 1; i++) &#123; arrmap[i][0] = new HashMap&lt;&gt;(); &#125; &#125; else &#123; System.out.println(&quot;txt中没有数据&quot;); &#125; columns = (dataList.get(0).split(delimiter)).length; for (int c = 0; c &lt; columns; c++) &#123; for (String key : dataList.get(0).split(delimiter))&#123; arrkey.add(key); &#125; &#125; for (int r = 1; r &lt; rows; r++) &#123; String[] values = dataList.get(r).split(delimiter); for (int c = 0; c &lt; columns; c++) &#123; String value = values[c]; arrmap[r - 1][0].put(arrkey.get(c), value); &#125; &#125; return arrmap; &#125; /** * 获得txt文件的路径 * @return * @throws IOException */ public String getPath() throws IOException &#123; File directory = new File(&quot;.&quot;); sourceFile = directory.getCanonicalPath() + &quot;\\\\src\\\\main\\\\resources\\\\data\\\\&quot; + fileName + &quot;.txt&quot;; return sourceFile; &#125; &#125; 使用123456789101112131415161718 public class TxtDataproviderTest &#123; @DataProvider(name = &quot;num&quot;) public Object[][] Numbers() throws BiffException, IOException &#123; TxtData data = new TxtData(&quot;testtxt&quot;, &quot;,&quot;); return data.getTxtDataByDelimiter(); &#125; @Test(priority = 1,dataProvider = &quot;num&quot;) public void test(HashMap&lt;String, String&gt; data)&#123; System.out.println(data.toString()); int num1 = Integer.parseInt(data.get(&quot;num1&quot;)); int num2 = Integer.parseInt(data.get(&quot;num2&quot;)); int result = Integer.parseInt(data.get(&quot;result&quot;)); Assert.assertEquals(num1+num2 , result); &#125; &#125;","categories":[{"name":"TestNG","slug":"TestNG","permalink":"https://zwljx.github.io/categories/TestNG/"}],"tags":[{"name":"TestNG","slug":"TestNG","permalink":"https://zwljx.github.io/tags/TestNG/"}]},{"title":"TestNG-DataProvider-1","slug":"TestNG-Data-1","date":"2021-10-25T01:51:15.000Z","updated":"2021-10-25T01:55:33.412Z","comments":true,"path":"2021/10/25/TestNG-Data-1/","link":"","permalink":"https://zwljx.github.io/2021/10/25/TestNG-Data-1/","excerpt":"自定义excel格式参数化文件处理工具类-POI库，支持高版本","text":"自定义excel格式参数化文件处理工具类-POI库，支持高版本 工具类实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120 public class ExcelDataNew &#123; public Workbook workbook; public Sheet sheet; public Cell cell; int rows; int columns; public String fileName; //区别于ExcelData，该fileName需要带后缀 public String caseName; public ArrayList&lt;String&gt; arrkey = new ArrayList&lt;String&gt;(); String sourceFile; /** * @param fileName excel文件名 * @param caseName sheet名 */ public ExcelDataNew(String fileName, String caseName) &#123; super(); this.fileName = fileName; this.caseName = caseName; setWorkbook(); &#125; /** * 判断，设置workbook * xls格式的需要使用HSSFWorkbook类来解析，xlsx格式的需要使用XSSFWorkbook格式来解析 */ public void setWorkbook()&#123; if(this.fileName == null)&#123; return; &#125; String extString = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); InputStream is = null; try &#123; is = new FileInputStream(getPath()); if(&quot;.xls&quot;.equals(extString))&#123; this.workbook = new HSSFWorkbook(is); &#125;else if(&quot;.xlsx&quot;.equals(extString))&#123; this.workbook = new XSSFWorkbook(is); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取cell中的值，转换为String类型 * @param cell * @return */ public static String getCellFormatValue(Cell cell) &#123; String cellValue = &quot;&quot;; if (cell != null) &#123; //判断cell类型 switch (cell.getCellType()) &#123; case Cell.CELL_TYPE_NUMERIC: &#123; cellValue = String.valueOf(cell.getNumericCellValue()); break; &#125; case Cell.CELL_TYPE_STRING: &#123; cellValue = cell.getRichStringCellValue().getString(); break; &#125; default: cellValue = &quot;&quot;; &#125; &#125; return cellValue; &#125; /** * 获得excel表中的数据 */ public Object[][] getExcelData() throws BiffException, IOException &#123; this.sheet = workbook.getSheet(caseName); this.rows = sheet.getPhysicalNumberOfRows(); this.columns = sheet.getRow(0).getPhysicalNumberOfCells(); // 为了返回值是Object[][],定义一个多行单列的二维数组 HashMap&lt;String, String&gt;[][] arrmap = new HashMap[rows - 1][1]; // 对数组中所有元素hashmap进行初始化 if (rows &gt; 1) &#123; for (int i = 0; i &lt; rows - 1; i++) &#123; arrmap[i][0] = new HashMap&lt;&gt;(); &#125; &#125; else &#123; System.out.println(&quot;excel中没有数据&quot;); &#125; // 获得首行的列名，作为hashmap的key值 Row rowHead = sheet.getRow(0); for (int c = 0; c &lt; columns; c++) &#123; String cellvalue = getCellFormatValue(rowHead.getCell(c)); arrkey.add(cellvalue); &#125; // 遍历所有的单元格的值添加到hashmap中 for (int r = 1; r &lt; rows; r++) &#123; Row row = sheet.getRow(r); for (int c = 0; c &lt; columns; c++) &#123; String cellvalue = getCellFormatValue(row.getCell(c)); arrmap[r - 1][0].put(arrkey.get(c), cellvalue); &#125; &#125; return arrmap; &#125; /** * 获得excel文件的路径 * @return * @throws IOException */ public String getPath() throws IOException &#123; File directory = new File(&quot;.&quot;); sourceFile = directory.getCanonicalPath() + &quot;\\\\src\\\\main\\\\resources\\\\data\\\\&quot; + fileName; return sourceFile; &#125; &#125; 使用1234567891011121314151617 public class ExcelDataproviderTest &#123; @DataProvider(name = &quot;num&quot;) public Object[][] Numbers() throws BiffException, IOException &#123; ExcelDataNew data = new ExcelDataNew(&quot;testexcel.xlsx&quot;, &quot;test&quot;); return data.getExcelData(); &#125; @Test(priority = 1, dataProvider = &quot;num&quot;) public void test(HashMap&lt;String, String&gt; data) &#123; System.out.println(data.toString()); int num1 = Integer.parseInt(data.get(&quot;num1&quot;)); int num2 = Integer.parseInt(data.get(&quot;num2&quot;)); int result = Integer.parseInt(data.get(&quot;result&quot;)); Assert.assertEquals(num1 + num2, result); &#125;&#125;","categories":[{"name":"TestNG","slug":"TestNG","permalink":"https://zwljx.github.io/categories/TestNG/"}],"tags":[{"name":"TestNG","slug":"TestNG","permalink":"https://zwljx.github.io/tags/TestNG/"}]},{"title":"React-第三方库和工具","slug":"react-lib","date":"2021-10-25T01:40:09.000Z","updated":"2021-10-25T01:47:30.973Z","comments":true,"path":"2021/10/25/react-lib/","link":"","permalink":"https://zwljx.github.io/2021/10/25/react-lib/","excerpt":"React 实用工具使用与第三方库","text":"React 实用工具使用与第三方库 工具JSON转换String转json对象：JSON.parse()json对象转json String：JSON.stringify() 百分比计算Math.round(value/total*10000)/100.00 时间格式转换12let sdate = new Date(r.create_time).toJSON();let sdate2 = new Date(+new Date(sdate) + 8 * 3600 * 1000).toISOString().replace(/T/g, &#x27; &#x27;).replace(/\\.[\\d]&#123;3&#125;Z/, &#x27;&#x27;); base64转换1234let string = window.atob(base64String);//直接atob会乱码，以下两行解决乱码问题string = escape(string);string = decodeURIComponent(string); 第三方库json组件1234import ReactJson from &#x27;react-json-view&#x27;;&lt;ReactJson src=&#123;this.state.jsonSrc&#125; name=&#123;null&#125; iconStyle=&quot;square&quot; collapseStringsAfterLength=&#123;30&#125; displayDataTypes=&#123;false&#125; collapsed=&#123;false&#125; style=&#123;&#123;fontFamily:&#x27;微软雅黑&#x27;&#125;&#125;/&gt; echarts组件12345678import ReactEcharts from &quot;echarts-for-react&quot;;import echartsTheme from &#x27;../../theme/tabletheme1&#x27;;componentWillMount()&#123; echarts.registerTheme(&#x27;theme&#x27;, echartsTheme); &#125;&lt;ReactEcharts option=&#123;this.getOption()&#125; style=&#123;&#123;height: 400&#125;&#125; theme=&quot;theme&quot;&gt;&lt;/ReactEcharts&gt; cookie操作1import cookie from &#x27;react-cookies&#x27;;","categories":[{"name":"React","slug":"React","permalink":"https://zwljx.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://zwljx.github.io/tags/React/"}]},{"title":"web-文件上传","slug":"web-file","date":"2021-10-25T01:32:48.000Z","updated":"2021-10-25T01:36:08.427Z","comments":true,"path":"2021/10/25/web-file/","link":"","permalink":"https://zwljx.github.io/2021/10/25/web-file/","excerpt":"web开发-文件上传功能","text":"web开发-文件上传功能 前端1234567891011121314151617181920212223242526&lt;div style=&#123;&#123;marginTop: 30, marginBottom: 20,width:&#x27;50%&#x27;,marginLeft: 20&#125;&#125;&gt; &lt;span style=&#123;&#123;display: &#x27;inline-block&#x27;, width: 150&#125;&#125;&gt; &lt;Icon type=&quot;to-top&quot;/&gt;上传单个文件&lt;/span&gt; &lt;Upload name=&quot;file&quot; action=&quot;http://localhost:8080/upload&quot; /*onChange = &#123;this.handleChange&#125; onRemove = &#123;this.remove&#125;*/&gt; &lt;Button&gt; &lt;Icon type=&quot;upload&quot; /&gt; Click to Upload &lt;/Button&gt; &lt;/Upload&gt; &lt;/div&gt; &lt;div style=&#123;&#123;marginTop: 30, marginBottom: 20,width:&#x27;50%&#x27;,marginLeft: 20&#125;&#125;&gt; &lt;span style=&#123;&#123;display: &#x27;inline-block&#x27;, width: 150&#125;&#125;&gt; &lt;Icon type=&quot;to-top&quot;/&gt;上传多个文件&lt;/span&gt; &lt;Upload name=&quot;file&quot; action=&quot;http://localhost:8080/multiUpload&quot; multiple=&#123;true&#125; /*onChange = &#123;this.handleChange&#125; onRemove = &#123;this.remove&#125;*/&gt; &lt;Button&gt; &lt;Icon type=&quot;upload&quot; /&gt; Click to Upload &lt;/Button&gt; &lt;/Upload&gt; &lt;/div&gt; 后端单文件上传1234567891011121314151617181920@PostMapping(&quot;/upload&quot;) @ResponseBody public String upload(@RequestParam(&quot;file&quot;) MultipartFile file) &#123; if (file.isEmpty()) &#123; return &quot;上传失败，请选择文件&quot;; &#125; try &#123; String fileName = file.getOriginalFilename(); File directory = new File(&quot;.&quot;); String filePath = directory.getCanonicalPath() + &quot;\\\\src\\\\main\\\\resources\\\\files\\\\&quot;; File dest = new File(filePath + fileName); file.transferTo(dest); System.out.println(&quot;success&quot;); return &quot;上传成功&quot;; &#125; catch (IOException e) &#123; System.out.println(&quot;fail&quot;); &#125; return &quot;上传失败！&quot;; &#125; 多文件上传12345678910111213141516171819202122232425262728293031@PostMapping(&quot;/multiUpload&quot;) @ResponseBody public String multiUpload(HttpServletRequest request) &#123; List&lt;MultipartFile&gt; files = ((MultipartHttpServletRequest) request).getFiles(&quot;file&quot;); File directory = new File(&quot;.&quot;); String filePath = null; try &#123; filePath = directory.getCanonicalPath() + &quot;\\\\src\\\\main\\\\resources\\\\files\\\\&quot;; &#125; catch (IOException e) &#123; e.printStackTrace(); return &quot;error&quot;; &#125; for (int i = 0; i &lt; files.size(); i++) &#123; MultipartFile file = files.get(i); if (file.isEmpty()) &#123; return &quot;上传第&quot; + (i++) + &quot;个文件失败&quot;; &#125; String fileName = file.getOriginalFilename(); File dest = new File(filePath + fileName); try &#123; file.transferTo(dest); System.out.println(&quot;第&quot; + (i + 1) + &quot;个文件上传成功&quot;); &#125; catch (IOException e) &#123; System.out.println(e.toString()); return &quot;上传第&quot; + (i++) + &quot;个文件失败&quot;; &#125; &#125; return &quot;上传成功&quot;; &#125; 文件操作工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import org.apache.commons.lang3.StringUtils;import java.io.*;import java.util.ArrayList;import java.util.List;public class FileUtil &#123; /** * 按行读取文件，一行为一个String * @param path filePath * @return */ public static List&lt;String&gt; readFile(String path)&#123; List&lt;String&gt; result = new ArrayList&lt;String&gt;(); FileReader reader = null; try &#123; reader = new FileReader(path); BufferedReader br = new BufferedReader(reader); String str = null; while ((str = br.readLine()) != null) &#123; if(StringUtils.isNotEmpty(str)) &#123; result.add(str); &#125; &#125; br.close(); reader.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return result; &#125; /** * 读文件结果保存为一个字符串中 */ public static String readFileToString (String path) &#123; File file02 = new File(path); FileInputStream is = null; StringBuilder stringBuilder = null; try &#123; if (file02.length() != 0) &#123; /** * 文件有内容才去读文件 */ is = new FileInputStream(file02); InputStreamReader streamReader = new InputStreamReader(is); BufferedReader reader = new BufferedReader(streamReader); String line; stringBuilder = new StringBuilder(); while ((line = reader.readLine()) != null) &#123; // stringBuilder.append(line); stringBuilder.append(line); &#125; reader.close(); is.close(); &#125; else &#123; return &quot;&quot;; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return String.valueOf(stringBuilder); &#125; /** * 写入文件 * @param path * @param */ public static void writeToFile(String path ,String content) &#123; FileWriter fw = null; try &#123; //如果文件存在，则追加内容；如果文件不存在，则创建文件 File f=new File(path); fw = new FileWriter(f, true); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; PrintWriter pw = new PrintWriter(fw); pw.println(content); pw.flush(); try &#123; fw.flush(); pw.close(); fw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public static void deleteFile(String path) &#123; File f = new File(path); if (f.exists())&#123; f.delete(); &#125; &#125;&#125;","categories":[{"name":"web","slug":"web","permalink":"https://zwljx.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://zwljx.github.io/tags/web/"}]},{"title":"React-登录","slug":"react-login","date":"2021-10-22T09:15:30.000Z","updated":"2021-10-22T09:22:00.938Z","comments":true,"path":"2021/10/22/react-login/","link":"","permalink":"https://zwljx.github.io/2021/10/22/react-login/","excerpt":"react 登录功能","text":"react 登录功能 登录功能实现页面-账号密码输入框、登录按钮采用Form表单： 123456789101112131415161718192021222324252627282930313233343536import &#123;Button,Form,Input&#125; from &#x27;antd&#x27;;const layout = &#123; labelCol: &#123; span: 8 &#125;, wrapperCol: &#123; span: 16 &#125;, &#125;; &lt;Form &#123;...layout&#125; name=&quot;basic&quot; initialValues=&#123;&#123; remember: true &#125;&#125; onFinish=&#123;this.onFinish&#125; onFinishFailed=&#123;this.onFinishFailed&#125; &gt; &lt;Form.Item label=&quot;Username&quot; name=&quot;username&quot; rules=&#123;[&#123; required: true, message: &#x27;Please input your username!&#x27; &#125;]&#125; &gt; &lt;Input /&gt; &lt;/Form.Item&gt; &lt;Form.Item label=&quot;Password&quot; name=&quot;password&quot; rules=&#123;[&#123; required: true, message: &#x27;Please input your password!&#x27; &#125;]&#125; &gt; &lt;Input.Password /&gt; &lt;/Form.Item&gt; &lt;Form.Item &#123;...tailLayout&#125;&gt; &lt;Button type=&quot;primary&quot; htmlType=&quot;submit&quot;&gt; Login &lt;/Button&gt; &lt;/Form.Item&gt;&lt;/Form&gt; 登录验证及cookie操作12345678910111213141516171819202122232425262728293031323334353637onFinish = (values) =&gt;&#123; console.log(values); let url = &quot;http://***.***.com/login&quot;; fetch(url, &#123; method: &#x27;POST&#x27;, headers: &#123; &#x27;Access-Control-Allow-Origin&#x27;: &#x27;*&#x27;, &#x27;Access-Control-Allow-Methods&#x27;:&#x27;POST, GET, OPTIONS, DELETE, PUT&#x27;, &#x27;Access-Control-Allow-Credentials&#x27;:&#x27;true&#x27;, &#x27;Accept&#x27;: &#x27;application/json&#x27;, &#x27;Content-Type&#x27;: &#x27;application/json;charset=utf-8&#x27;, &#x27;mode&#x27;:&#x27;no-cors&#x27;, &#x27;Access-Control-Allow-Headers&#x27;:&#x27;Accept,Authorization,Cache-Control,Content-Type,DNT,If-Modified-Since,Keep-Alive,Origin,User-Agent,X-Requested-With,Token,x-access-token&#x27;, &#125;, credentials: &#x27;include&#x27;, body: JSON.stringify(values), &#125;).then(response =&gt; response.json()) .then(responseJson =&gt; &#123; //处理登录请求结果 if (responseJson.code === &quot;0&quot;) &#123; //cookie有效期1个小时 cookie.save(&#x27;user&#x27;, values.username,&#123;path:&quot;/&quot;,maxAge:3600&#125;); message.success(&quot;login success&quot;); this.props.history.push(&#x27;/home&#x27;, null); &#125;else &#123; message.error(&quot;login failed&quot;); &#125; console.log(responseJson); &#125;).catch(function (e) &#123; console.log(&quot;Oops, error&quot;); message.error(&quot;login failed&quot;) &#125;); &#125; onFinishFailed = (errorInfo ) =&gt;&#123; console.log(&#x27;Failed:&#x27;, errorInfo); &#125; 登录态失效判断及跳转123456componentWillMount()&#123; console.log(&quot;user = &quot; + cookie.load(&quot;user&quot;)); if (cookie.load(&quot;user&quot;) === undefined || cookie.load(&quot;user&quot;) === null) &#123; this.props.history.push(&#x27;/login&#x27;, null); &#125; &#125; 注意：页面跳转失效处理如下123import &#123;withRouter&#125; from &#x27;react-router-dom&#x27;; class HomePage extends Component&#123;&#125; export default withRouter(HomePage); 权限根据cookie中存储的用户信息，判断是否对页面上某些元素可见 123456789let hasPermission = this.hasPermission(cookie.load(&quot;user&quot;));hasPermission = (user) =&gt; &#123; if (user === &quot;admin&quot;)&#123; return true; &#125; else &#123; return false; &#125; &#125;&#123;hasCallPermission?&lt;div&gt;……&lt;/div&gt;:null&#125;","categories":[{"name":"React","slug":"React","permalink":"https://zwljx.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://zwljx.github.io/tags/React/"}]},{"title":"React-excel","slug":"react-excel","date":"2021-10-22T09:10:21.000Z","updated":"2021-10-22T09:13:41.437Z","comments":true,"path":"2021/10/22/react-excel/","link":"","permalink":"https://zwljx.github.io/2021/10/22/react-excel/","excerpt":"React前端实现excel的导出","text":"React前端实现excel的导出 工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//excelUtil.jsimport XLSX from &#x27;xlsx&#x27;;import React,&#123;useState,useEffect&#125; from &#x27;react&#x27;;function importExcel(file)&#123; // 获取上传的文件对象 const &#123; files &#125; = file.target; // 通过FileReader对象读取文件 const fileReader = new FileReader(); fileReader.onload = event =&gt; &#123; try &#123; const &#123; result &#125; = event.target; // 以二进制流方式读取得到整份excel表格对象 const workbook = XLSX.read(result, &#123; type: &#x27;binary&#x27; &#125;); let data = []; // 存储获取到的数据 // 遍历每张工作表进行读取（这里默认只读取第一张表） for (const sheet in workbook.Sheets) &#123; if (workbook.Sheets.hasOwnProperty(sheet)) &#123; // 利用 sheet_to_json 方法将 excel 转成 json 数据 data = data.concat(XLSX.utils.sheet_to_json(workbook.Sheets[sheet])); // break; // 如果只取第一张表，就取消注释这行 &#125; &#125; console.log(data); &#125; catch (e) &#123; // 这里可以抛出文件类型错误不正确的相关提示 console.log(&#x27;文件类型不正确&#x27;); return; &#125; &#125;; // 以二进制方式打开文件 fileReader.readAsBinaryString(files[0]);&#125;function exportExcel(headers, data, fileName = &#x27;请假记录表.xlsx&#x27;) &#123; const _headers = headers .map((item, i) =&gt; Object.assign(&#123;&#125;, &#123; key: item.key, title: item.title, position: String.fromCharCode(65 + i) + 1 &#125;)) .reduce((prev, next) =&gt; Object.assign(&#123;&#125;, prev, &#123; [next.position]: &#123; key: next.key, v: next.title &#125; &#125;), &#123;&#125;); const _data = data .map((item, i) =&gt; headers.map((key, j) =&gt; Object.assign(&#123;&#125;, &#123; content: item[key.key], position: String.fromCharCode(65 + j) + (i + 2) &#125;))) // 对刚才的结果进行降维处理（二维数组变成一维数组） .reduce((prev, next) =&gt; prev.concat(next)) // 转换成 worksheet 需要的结构 .reduce((prev, next) =&gt; Object.assign(&#123;&#125;, prev, &#123; [next.position]: &#123; v: next.content &#125; &#125;), &#123;&#125;); // 合并 headers 和 data const output = Object.assign(&#123;&#125;, _headers, _data); // 获取所有单元格的位置 const outputPos = Object.keys(output); // 计算出范围 ,[&quot;A1&quot;,..., &quot;H2&quot;] const ref = `$&#123;outputPos[0]&#125;:$&#123;outputPos[outputPos.length - 1]&#125;`; // 构建 workbook 对象 const wb = &#123; SheetNames: [&#x27;mySheet&#x27;], Sheets: &#123; mySheet: Object.assign( &#123;&#125;, output, &#123; &#x27;!ref&#x27;: ref, &#x27;!cols&#x27;: [&#123; wpx: 45 &#125;, &#123; wpx: 100 &#125;, &#123; wpx: 200 &#125;, &#123; wpx: 80 &#125;, &#123; wpx: 150 &#125;, &#123; wpx: 100 &#125;, &#123; wpx: 300 &#125;, &#123; wpx: 300 &#125;], &#125;, ), &#125;, &#125;; // 导出 Excel XLSX.writeFile(wb, fileName);&#125;export default &#123;importExcel,exportExcel&#125;; 应用12import ExcelUtil from &quot;../../component/ExcelUtil/ExcelUtil&quot;;&lt;Button type=&quot;primary&quot; onClick=&#123;() =&gt; &#123;ExcelUtil.exportExcel(columns, this.state.taskListData,&quot;结果.xlsx&quot;)&#125;&#125;&gt;导出&lt;/Button&gt;","categories":[{"name":"React","slug":"React","permalink":"https://zwljx.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://zwljx.github.io/tags/React/"}]},{"title":"linux-后台执行","slug":"linux-1","date":"2021-10-22T06:24:32.000Z","updated":"2021-10-22T08:51:41.610Z","comments":true,"path":"2021/10/22/linux-1/","link":"","permalink":"https://zwljx.github.io/2021/10/22/linux-1/","excerpt":"后台运行","text":"后台运行 1nohup [command] &amp; 该命令启动的后台进程可能会被杀掉，解决办法是写在一个脚本里面，示例如下： 12345#!/bin/bashBUILD_ID=dontKillMenohup [command] &amp; 执行该脚本","categories":[{"name":"linux","slug":"linux","permalink":"https://zwljx.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://zwljx.github.io/tags/linux/"}]},{"title":"selenium-编码前准备","slug":"selenium-1","date":"2021-10-22T06:13:52.000Z","updated":"2021-10-22T06:21:24.997Z","comments":true,"path":"2021/10/22/selenium-1/","link":"","permalink":"https://zwljx.github.io/2021/10/22/selenium-1/","excerpt":"selenium Java编码准备","text":"selenium Java编码准备 selenium Java maven依赖12345&lt;dependency&gt; &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt; &lt;artifactId&gt;selenium-java&lt;/artifactId&gt; &lt;version&gt;2.44.0&lt;/version&gt;&lt;/dependency&gt; selenum 启动firefox浏览器注意事项selenium启动Firefox，不需要额外的driver如果没有安装到默认路径C盘，需要设置路径 12System.setProperty(&quot;webdriver.firefox.bin&quot;,&quot;D:/……/Mozilla Firefox/firefox.exe&quot;);WebDriver driver = new FirefoxDriver(); firefox的版本与selenium的版本对应关系 【Selenium】 -&gt; 【FireFox】2.25.0 -&gt; 182.30.0 -&gt; 192.31.0 -&gt; 202.42.2 -&gt; 292.44.0 -&gt; 33 (不支持31)2.53.0 -&gt; 43,46(不支持47)2.41.0 -&gt; 26(绿色版本)2.44 -&gt; 32.0-35.0 chrome版本与chromedriver版本对应关系 ChromeDriver Version Chrome Version 83.0.4103.39 83 83.0.4103.14 83 81.0.4044.138 81 81.0.4044.69 81 81.0.4044.20 81 80.0.3987.106 80 80.0.3987.16 80 79.0.3945.36 79 79.0.3945.16 79 78.0.3904.105 78 78.0.3904.70 78 78.0.3904.11 78 77.0.3865.40 77 77.0.3865.10 77 76.0.3809.126 76 76.0.3809.68 76 76.0.3809.25 76 76.0.3809.12 76 75.0.3770.90 75 75.0.3770.8 75 74.0.3729.6 74 73.0.3683.68 73 72.0.3626.69 72 2.46 71-73 2.46 71-73 2.45 70-72 2.44 69-71 2.43 69-71 2.42 68-70 2.41 67-69 2.40 66-68 2.39 66-68 2.38 65-67 2.37 64-66 2.36 63-65 2.35 62-64","categories":[{"name":"selenium","slug":"selenium","permalink":"https://zwljx.github.io/categories/selenium/"}],"tags":[{"name":"selenium","slug":"selenium","permalink":"https://zwljx.github.io/tags/selenium/"}]},{"title":"Git知识点总结","slug":"git","date":"2021-10-22T05:57:35.000Z","updated":"2021-10-22T06:17:39.195Z","comments":true,"path":"2021/10/22/git/","link":"","permalink":"https://zwljx.github.io/2021/10/22/git/","excerpt":"git操作总结","text":"git操作总结 初级工作流 working directory是操作目录staging area是暂存区，用来保存变化repository是仓库，保存作为一个版本的变化 基础命令git initgit statusgit diffgit loggit refloggit add [. | filenames]git commit -m “message &lt;=50 characters” HEADHEAD:当前所在版本HEAD^:上一个版本HEAD~n:上n个版本SHA：40 characters 唯一标识取至少7位 中级分支git branch 当前分支git branch new_branch 新建分支git checkout branch_name 切换分支git merge branch_name(提供者分支名称) 合并到当前分支git branch -d branch_name 删除分支注：若有冲突conflict，需要手动修改，再add、 commit teamworkgit clone remote_location(from) clone_name(to)克隆远端的仓库到本地git remote -v 查看远端仓库的版本信息git fetch 查看远端修改（这个操作只是合并到了本地的origin/master,不是本地的local/master）git push your_branch_name 上传到远端注：origin/master 标志远端HEAD的位置git fetch区别于git pull：fetch不会自动merge，pull会自动merge。fetch更安全使用Github需要先fork到自己的账号下，再从自己的账号下clone，才可以提交修改 工作流程一般的使用git来做版本控制的工作流程如下：①fetch and merge （=pull）②创建新分支来开发新的功能③开发、commit④fetch and merge⑤push your branch to remote 高级reset和checkout这是与回退相关的两个常用命令，到底什么时候该用哪个命令，具体用法和区别如下： reset命令一般用于版本回退：注意不只是可以做仓库的版本回退。使用如下：命令格式：git reset [- -参数] [commit-id] [filename]hard：HEAD INDEX WORKING都改变mixed：HEAD INDEX改变（默认）soft: HEAD改变加文件名代表只有该文件做回退，不加代表所有文件均回退 checkout有两个作用：切换分支和撤销修改（指修改工作区，仓库的版本都还存在）撤销修改：①git checkout - -[.|filename]若add过，回到add之后的状态。若没有add过，回到上一次commit②工作区内容回到上一次或者上n次的版本git checkout commit-id filename 或者 先reset在checkout - - 两种方式的对比：前者容易误操作，但是保留了该文件工作区目标版本之后的几个版本。后者不容易误操作，但是几个版本会丢失。 关于前者的误操作和解决方式：filename是必须加的，若不加，该命令将使HEAD指针不再指向最新的版本，而是处于游离状态。解决方法是：checkout到master分支，但若目前已有修改无法切换到master分支。则新建temp分支，commit再合并到master分支，然后删除temp分支。可以将HEAD指针回到最新版本的位置。 git stash当前分支工作未完成，不能commit，但是要切换到其他分支去工作。问题是：不commit修改无法切换到其他分支。因此要用到stash。git stash 备份git stash pop 读取并恢复（pop命令之后不再有，apply之后还有）git stash listgit stash clear 清空git stash apply [stash @{1}]git stash drop [&lt; stash &gt;]删除某进度，默认最新注：不能保存untracked files，需要加-u参数 github的使用（摘了网上的）配置Git 首先在本地创建ssh key；ssh-keygen -t rsa -C “&#x79;&#x6f;&#x75;&#114;&#95;&#101;&#x6d;&#97;&#105;&#108;&#x40;&#x79;&#x6f;&#x75;&#x72;&#x65;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#109;”后面的&#121;&#x6f;&#x75;&#114;&#x5f;&#101;&#109;&#x61;&#105;&#x6c;&#x40;&#x79;&#111;&#x75;&#114;&#x65;&#x6d;&#97;&#105;&#108;&#46;&#99;&#111;&#109;改为你在github上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在~/下生成.ssh文件夹，进去，打开id_rsa.pub，复制里面的key。回到github上，进入 Account Settings（账户配置），左边选择SSH Keys，Add SSH Key,title随便填，粘贴在你电脑上生成的key。github-account为了验证是否成功，在git bash下输入：ssh -T &#103;&#105;&#116;&#64;&#x67;&#x69;&#x74;&#104;&#117;&#x62;&#x2e;&#x63;&#111;&#x6d;如果是第一次的会提示是否continue，输入yes就会看到：You’ve successfully authenticated, but GitHub does not provide shell access 。这就表示已成功连上github。 把本地仓库传到github上去，在此之前还需要设置username和email，因为github每次commit都会记录他们。git config –global user.name “your name”git config –global user.email “&#x79;&#x6f;&#117;&#114;&#95;&#101;&#109;&#97;&#x69;&#108;&#x40;&#121;&#x6f;&#117;&#114;&#x65;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;”进入要上传的仓库，右键git bash，添加远程地址：git remote add origin &#x67;&#105;&#116;&#x40;&#103;&#x69;&#116;&#x68;&#x75;&#x62;&#x2e;&#99;&#111;&#109;:yourName/yourRepo.git后面的yourName和yourRepo表示你再github的用户名和刚才新建的仓库，加完之后进入.git，打开config，这里会多出一个remote “origin”内容，这就是刚才添加的远程地址，也可以直接修改config来配置远程地址。 创建新文件夹，打开，然后执行 git init 以创建新的 git 仓库。检出仓库执行如下命令以创建一个本地仓库的克隆版本：git clone /path/to/repository如果是远端服务器上的仓库，你的命令会是这个样子：git clone username@host:/path/to/repository","categories":[{"name":"git","slug":"git","permalink":"https://zwljx.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://zwljx.github.io/tags/git/"}]},{"title":"开源协议","slug":"other-OpenSourceLicense","date":"2021-10-22T01:54:07.000Z","updated":"2021-10-22T05:55:03.400Z","comments":true,"path":"2021/10/22/other-OpenSourceLicense/","link":"","permalink":"https://zwljx.github.io/2021/10/22/other-OpenSourceLicense/","excerpt":"开源协议常见的开源协议有GPL、BSD、MIT、Mozilla、Apache和LGPL等。","text":"开源协议常见的开源协议有GPL、BSD、MIT、Mozilla、Apache和LGPL等。 概述总结按照限制由少到多排序：MIT BSD Apache LGPL Mozilla GPL 协议详情MIT 源自麻省理工学院（Massachusetts Institute of Technology, MIT），又称X11协议，目前最少限制的协议。唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。 BSD BSD是”Berkeley Software Distribution”的缩写，意思是”伯克利软件发行版”。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。 发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件： - 如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。 - 如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。 - 不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。 Apache Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和最终原作者的著作权，同样允许源代码修改和再发布。但是也需要遵循以下条件： - 需要给代码的用户一份Apache Licence。 - 如果修改了代码，需要再被修改的文件中说明。 - 在衍生的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。 - 如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以再Notice中增加自己的许可，但是不可以表现为对Apache Licence构成更改。Apache Licence也是对商业应用友好的许可。使用者也可以再需要的时候修改代码来满足并作为开源或商业产品发布/销售。使用这个协议的好处是: - 永久权利 一旦被授权，永久拥有。 - 全球范围的权利 在一个国家获得授权，适用于所有国家。假如你在美国，许可是从印度授权的，也没有问题。 - 授权免费 无版税， 前期、后期均无任何费用。 - 授权无排他性 任何人都可以获得授权 - 授权不可撤消 一旦获得授权，没有任何人可以取消。比如，你基于该产品代码开发了衍生产品，你不用担心会在某一天被禁止使用该代码 LGPL LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。 Mozilla (Mozilla Public License 1.1)MPL协议允许免费重发布、免费修改，但要求修改后的代码版权归软件的发起者 。这种授权维护了商业软件的利益，它要求基于这种软件的修改无偿贡献版权给该软件。这样，围绕该软件的所有代码的版权都集中在发起开发人的手中。但MPL是允许修改，无偿使用得。MPL软件对链接没有要求。 GPL GPL （GNU General Public License） ：GNU通用公共许可协议。Linux 采用了 GPL。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软件了。","categories":[{"name":"other","slug":"other","permalink":"https://zwljx.github.io/categories/other/"}],"tags":[{"name":"other","slug":"other","permalink":"https://zwljx.github.io/tags/other/"}]},{"title":"React-echarts","slug":"react-echarts","date":"2021-10-21T08:18:02.000Z","updated":"2021-10-22T09:11:15.365Z","comments":true,"path":"2021/10/21/react-echarts/","link":"","permalink":"https://zwljx.github.io/2021/10/21/react-echarts/","excerpt":"主题从官网导出主题js文件，将主题配置用export default{}封装，在页面代码中引入","text":"主题从官网导出主题js文件，将主题配置用export default{}封装，在页面代码中引入 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import echarts from &#x27;echarts/lib/echarts&#x27;;import ReactEcharts from &quot;echarts-for-react&quot;;import echartsTheme from &#x27;../../theme/tabletheme1&#x27;;class EchartsTest extends Component&#123; componentWillMount()&#123; //注册意图 echarts.registerTheme(&#x27;theme&#x27;, echartsTheme); &#125; getOption = () =&gt; &#123; let option = &#123; toolbox:&#123; feature:&#123; saveAsImage:&#123; name:&quot;test&quot; + Date.parse(new Date()), &#125; &#125; &#125;, title: &#123; text: &#x27;test&#x27;, subtext: &#x27;test&#x27;, left: &#x27;center&#x27; &#125;, legend: &#123; orient: &#x27;vertical&#x27;, left: &#x27;left&#x27;, data: [&#x27;data1&#x27;, &#x27;data2&#x27;] &#125;, series: [&#123; name: &#x27;test&#x27;, type: &#x27;pie&#x27;, radius: &#x27;55%&#x27;, center: [&#x27;50%&#x27;, &#x27;50%&#x27;], label: &#123; normal: &#123; show: true, formatter: &#x27;&#123;b&#125;: &#123;c&#125;(&#123;d&#125;%)&#x27; &#125; &#125;, data: this.state.callNum, emphasis: &#123; itemStyle: &#123; shadowBlur: 10, shadowOffsetX: 0, shadowColor: &#x27;rgba(0, 0, 0, 0.5)&#x27; &#125; &#125; &#125;], tooltip:&#123; show: true, trigger: &#x27;item&#x27;, formatter: &#x27;&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&#x27; //formatter: &quot;&#123;a0&#125; &lt;br/&gt; &#123;b&#125; : &#123;c0&#125; &lt;br/&gt; &#123;a1&#125; &lt;br/&gt; &#123;c1&#125;%&quot; &#125; &#125; return option; &#125; render()&#123; return( &lt;ReactEcharts option=&#123;this.getOption()&#125; style=&#123;&#123;height: 400&#125;&#125; theme=&quot;theme&quot;&gt;&lt;/ReactEcharts&gt; ); &#125;&#125;export default EchartsTest;","categories":[{"name":"React","slug":"React","permalink":"https://zwljx.github.io/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://zwljx.github.io/tags/React/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-10-21T06:14:44.625Z","updated":"2021-10-21T08:11:20.661Z","comments":true,"path":"2021/10/21/hello-world/","link":"","permalink":"https://zwljx.github.io/2021/10/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hello","slug":"Hello","permalink":"https://zwljx.github.io/categories/Hello/"}],"tags":[{"name":"hello","slug":"hello","permalink":"https://zwljx.github.io/tags/hello/"}]}],"categories":[{"name":"TestNG","slug":"TestNG","permalink":"https://zwljx.github.io/categories/TestNG/"},{"name":"React","slug":"React","permalink":"https://zwljx.github.io/categories/React/"},{"name":"web","slug":"web","permalink":"https://zwljx.github.io/categories/web/"},{"name":"linux","slug":"linux","permalink":"https://zwljx.github.io/categories/linux/"},{"name":"selenium","slug":"selenium","permalink":"https://zwljx.github.io/categories/selenium/"},{"name":"git","slug":"git","permalink":"https://zwljx.github.io/categories/git/"},{"name":"other","slug":"other","permalink":"https://zwljx.github.io/categories/other/"},{"name":"Hello","slug":"Hello","permalink":"https://zwljx.github.io/categories/Hello/"}],"tags":[{"name":"TestNG","slug":"TestNG","permalink":"https://zwljx.github.io/tags/TestNG/"},{"name":"React","slug":"React","permalink":"https://zwljx.github.io/tags/React/"},{"name":"web","slug":"web","permalink":"https://zwljx.github.io/tags/web/"},{"name":"linux","slug":"linux","permalink":"https://zwljx.github.io/tags/linux/"},{"name":"selenium","slug":"selenium","permalink":"https://zwljx.github.io/tags/selenium/"},{"name":"git","slug":"git","permalink":"https://zwljx.github.io/tags/git/"},{"name":"other","slug":"other","permalink":"https://zwljx.github.io/tags/other/"},{"name":"hello","slug":"hello","permalink":"https://zwljx.github.io/tags/hello/"}]}